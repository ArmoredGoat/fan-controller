#!/usr/bin/env python

"""
ArmoredGoat's Fan Controller for 4-pin fans.

Based on the script read_RPM.py (2016-01-20; Public Domain) found under 
https://abyz.me.uk/rpi/pigpio/examples.html as "RPM Monitor"
"""

import time
import pigpio # http://abyz.co.uk/rpi/pigpio/python.html

# Set GPIO pin numbers (BCM naming). See https://pinout.xyz/
PWM_GPIO = 18
RPM_GPIO = 24

# Set interval time in seconds at which temperature and rpm are to be measured
LOOP_DURATION = 30

# Set path to file which contains the measured temperature of the ds18b20
# temperature sensor
PATH_TEMPERATURE_FILE = "/sys/bus/w1/devices/28-00000ca660dd/w1_slave"


class FanController:
    """
    A class to read speedometer pulses and calculate the RPM.
    """
    def __init__(self, pi, gpio, pulses_per_rev=2.0, weighting=0.5, min_rpm=5.0):
        """
        Instantiate with the Pi and gpio of the RPM signal
        to monitor.

        Optionally the number of pulses for a complete revolution
        may be specified.  It defaults to 1.

        Optionally a weighting may be specified.  This is a number
        between 0 and 1 and indicates how much the old reading
        affects the new reading.  It defaults to 0 which means
        the old reading has no effect.  This may be used to
        smooth the data.

        Optionally the minimum RPM may be specified.  This is a
        number between 1 and 1000.  It defaults to 5.  An RPM
        less than the minimum RPM returns 0.0.
        """
        self.pi = pi
        self.gpio = gpio
        self.pulses_per_rev = pulses_per_rev

        self.duty_cycle_value = 0
        self.from_higher_threshold = False
        self.counter = 0

        if min_rpm > 1000.0:
            min_rpm = 1000.0
        elif min_rpm < 1.0:
            min_rpm = 1.0

        self.min_rpm = min_rpm

        self._watchdog = 200 # Milliseconds.

        if weighting < 0.0:
            weighting = 0.0
        elif weighting > 0.99:
            weighting = 0.99

        self._new = 1.0 - weighting # Weighting for new reading.
        self._old = weighting       # Weighting for old reading.

        self._high_tick = None
        self._period = None

        pi.set_mode(gpio, pigpio.INPUT)

        self._cb = pi.callback(gpio, pigpio.RISING_EDGE, self._cbf)
        pi.set_watchdog(gpio, self._watchdog)


    def _cbf(self, gpio, level, tick):

        if level == 1: # Rising edge.

            if self._high_tick is not None:
                t = pigpio.tickDiff(self._high_tick, tick)

                if self._period is not None:
                    self._period = (self._old * self._period) + (self._new * t)
                else:
                    self._period = t

            self._high_tick = tick

        elif level == 2: # Watchdog timeout.

            if self._period is not None:
                if self._period < 2000000000:
                    self._period += (self._watchdog * 1000)


    def get_rpm(self):
        """
        Returns the rpm.
        """
        rpm = 0.0
        if self._period is not None:
            rpm = 60000000.0 / (self._period * self.pulses_per_rev)
            if rpm < self.min_rpm:
                rpm = 0.0

        return rpm


    def clean_up(self, pi):
        """
        Cancels the reader and releases resources.
        """
        self.pi.set_watchdog(self.gpio, 0) # cancel watchdog
        self._cb.cancel()
        
        print("Clean up...")
        pi.stop()


    def get_temperature(self, path):
        """
        Function to read the temperature out of the file generated by the
        temperature sensor.
        """

        # Open temperature file and assign content to variable
        with open(path, 'r', encoding="utf-8") as f:
            content = f.read()

        # The content has the following format:
        # 59 01 4b 46 7f ff 07 10 a2 : crc=a2 YES
        # 59 01 4b 46 7f ff 07 10 a2 t=21562
        #
        # To get the desired value at the end of the second line,
        # the content is split at the new line character \n first
        # and then at space characters. Then we select the tenth
        # field with the index [9].
        # Afterwards we take the characters from index 2 to the end,
        # convert them to a decimal number, and divide it by 1000
        # to get the correct order of magnitude.
        string_temperature = content.split("\n")[1].split(" ")[9]
        temperature = float(string_temperature[2:])/1000

        return temperature


    def get_duty_cycle(self, temperature):
        """
        Function to determine and periodically reevaluate the desired 
        duty cycle.
        """

        # Temperature threshold in degrees Celcius to which the duty cycle is
        # orientated. These values are highly depending on personell
        # preferences, location, season, etc.
        #
        # Set these to your liking.

        threshold_one = 22
        threshold_two = 27
        threshold_three = 32
        threshold_four = 40

        # Set value to given value/value of last loop
        duty_cycle_value = self.duty_cycle_value

        # To prevent the fan speed from spinning up and down every other loop
        # when the (ambient) temperature is near a threshold, I implemented
        # a flag to check if the temperature is decreasing or rather the
        # temperature was in a higher threshold before. If yes, the fans will
        # spin with the duty cycle of the higher threshold range until it cooled
        # down another two degrees.
        # Contrary, if the temperature rises and surpass the upper threshold
        # despite the faster spinning fans, the flag will also get set to False
        # to let the controller react to this uncommon circumstance.

        # RIGHT NOW, THIS IS HARDCODED. I WILL FIND A SHORTER, MORE DYNAMIC WAY
        # LATER. (HOPEFULLY...)
        print(self.from_higher_threshold)
        if self.from_higher_threshold:
            if duty_cycle_value == 90 and (temperature < threshold_one - 2 \
                    or temperature >= threshold_two):
                self.from_higher_threshold = False
            elif duty_cycle_value == 128 and (temperature < threshold_two - 2 \
                    or temperature >= threshold_three):
                self.from_higher_threshold = False
            elif duty_cycle_value == 191 and (temperature < threshold_three - 2 \
                    or temperature >= threshold_four):
                self.from_higher_threshold = False
            elif duty_cycle_value == 255 and temperature < threshold_four - 2:
                self.from_higher_threshold = False

            # If the temperature is stuck in the hysteresis (e.g. coming from
            # 23.5 degree Celcius down to 21.5 degree Celsius) and therefore
            # the fans do not spin down to 20% duty cycle, the counter below
            # increases every loop from_higher_threshold is True. If it
            # reaches a set value it sets from_higher_threshold to False and
            # let the controller reevaluate its duty cycle setting.
            # At a loop time of 30 seconds a counter limit of 10 would let
            # the controller reevaluate its duty cycle setting after 5
            # minutes of being stuck in the hysteresis.

            self.counter += 1

            if self.counter > 10:
                self.from_higher_threshold = False
                self.counter = 0

        # If it is the first loop after starting the script or hysteresis of 2
        # degrees Celcius is undercut, set duty cycle accordingly to temperature

        if not self.from_higher_threshold:
            if temperature < threshold_one:
                duty_cycle_value = 51
            elif threshold_one <= temperature <= threshold_two:
                duty_cycle_value = 90
            elif threshold_two <= temperature <= threshold_three:
                duty_cycle_value = 128
            elif threshold_three <= temperature <= threshold_four:
                duty_cycle_value = 191
            elif temperature > threshold_four:
                duty_cycle_value = 255

            # If the duty cycle is set to a higher value then 51 and therefore
            # a lower threshold exists, set from_higher_value to True so it can
            # be checked if the hysteresis is met next loop.

            if duty_cycle_value > 51 and not self.from_higher_threshold:
                self.from_higher_threshold = True
                self.counter = 0 # Reset "stuck in hysteresis" counter

        # Update self.duty_cycle_value for next loop
        self.duty_cycle_value = duty_cycle_value

        # Convert duty cycle values to percentages
        duty_cycle_percent = int(round((duty_cycle_value / 255), 2) * 100)

        return [duty_cycle_value, duty_cycle_percent]


def main():
    """
    Main function to aggregate and call other needed functions.
    """

    # Create object of pi class
    pi = pigpio.pi()

    # Create object of FanController class
    p = FanController(pi, RPM_GPIO)

    try:
        while True:
            # Set start time to determine when the next loop shall start
            time_start = time.time()

            # Get temperature from sensor
            temperature = p.get_temperature(PATH_TEMPERATURE_FILE)
            print(f"T={temperature}Â°C")

            duty_cycle = p.get_duty_cycle(temperature)
            print(f"DC={duty_cycle[1]}%")
            pi.set_PWM_dutycycle(PWM_GPIO, duty_cycle[0])

            rpm = p.get_rpm()

            print(f"RPM={int(rpm + 0.5)}\n")

            # Wait until desired loop duration is reached until starting the
            # next loop.
            while (time.time() - time_start) < LOOP_DURATION:
                time.sleep(0.2)
    finally:
        p.clean_up(pi)


if __name__ == "__main__":
    main()
